#!/usr/bin/env python
# -*- coding: utf-8 -*-
#       "$Name: lkrause@cells.es $";
#       "$Header:  $";
#=============================================================================
#
# file :        BrukerBend_PS.py
#
# description : Python source for the BrukerBend_PS and its commands.
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                BrukerBend_PS are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  Lothar Krause <lkrause@cells.es> $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#               This file is generated by POGO
#       (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


class Release(object):
    pass

"""
Used to provide a single Tango server for both bending magnet power supplies.
It allows also to synchronize dipoles and quadrupoles PS at the same time.
"""
import PyTango as Tg
import sys
import ps_standard as PS
import traceback
import ps_util as PU
import re
from time import time
from pprint import pprint

AQ_ALARM = Tg.AttrQuality.ATTR_ALARM
AQ_WARNING = Tg.AttrQuality.ATTR_WARNING
AQ_VALID = Tg.AttrQuality.ATTR_VALID
AQ_INVALID = Tg.AttrQuality.ATTR_INVALID
AQ_CHANGING = Tg.AttrQuality.ATTR_CHANGING

DevState = Tg.DevState
ON = Tg.DevState.ON
OFF = Tg.DevState.OFF
STANDBY = Tg.DevState.STANDBY
ALARM = Tg.DevState.ALARM
MOVING = Tg.DevState.MOVING

BEND_FAULT_STATE = frozenset( (0x0c, 0x0d) )
BEND_ON_STATE = 0x0a  # power on
BEND_OFF_STATE = 0x03 # IDLE (DC off)

BEND_ON_T = {
    0x0A : 0.0,
    0x03 : 70, # 65.0,
    0x08 : 6.03
}


BEND_OFF_T = {
    0x03 : 0.0,
    0x0A : 22.0,
}

CAB_ON_STATES= (0x06, 9, 10)
CAB_OFF_STATE = 0x01
CAB_FAULT_STATE = frozenset( (0x08,) )

CAB_ON_T = {
    0x06 : 0.0,  # cabinet ready
    0x01 : 124.42,
}

CAB_OFF_T = {
    0x01 : 0.0,
    0x06 : 104.2779779
}

SWITCH_NEUTRAL = 'sw 0'
SWITCH_ON = 'sw on'
SWITCH_OFF = 'sw off'
DB = PS.DATABASE

tv2time = lambda x: x.tv_sec + x.tv_usec/1000.0

SECONDS_PAT = re.compile(r'^(.*) (\d*.\d+)s$')

def strip_s(x):
    mat = SECONDS_PAT.match(x)
    if mat is None:
        return x,None
    else:
        return mat.group(1), float(mat.group(2))

def WaveStatus_okay(v):
    return 'ing...' in v or 'finished' in v or v=='ready'

def merge_str(v1,v2):
    tail = ''
    for x,y in zip(v1[::-1],v2[::-1]):
        if x==y:
            tail+=x
        else:
            break
    tail = tail[::-1]
    n = len(tail)
    return v1[:-n].strip()+' / '+v2[:-n].strip()+' '+tail.strip()

class BrukerBend_PS(PS.PowerSupply):

#------------------------------------------------------------------
#       Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PS.PowerSupply.__init__(self,cl,name)
        BrukerBend_PS.init_device(self)

    def init_device(self):
        PS.PowerSupply.init_device(self)
        self.__shiver = {}
        self.switching = SWITCH_NEUTRAL
        self.switch_eta = 0
        self._aWaveGeneration = None
        self.next_update_t = 0

        self.bend1 = Tg.DeviceProxy(self.Bend1)
        self.bend2 = Tg.DeviceProxy(self.Bend2)

        def find_cab(ec_name):
            """finds name of BrukerEC_Cabinet corresponding to
               the device name specified
            """
            serv_name = 'BrukerEC_PS/bo_b'+ec_name[-1]
            print serv_name
            ls = DB.get_device_class_list(serv_name)
            dictum = dict(zip(ls[1::2],ls[::2]))
            return dictum['BrukerEC_Cabinet']

        self.bend1.cab = Tg.DeviceProxy(find_cab(self.Bend1))
        self.bend2.cab = Tg.DeviceProxy(find_cab(self.Bend2))

        # threshold when warning / alarms will be signalled
        self.AbsDiff = 0.1
        self.cabq = Tg.DeviceProxy(self.QuadCabinet)
        self.trig = Tg.DeviceProxy(self.Trigger)

        # prepares also DeviceProxy for the Synchronization
        self.sync_devices = [ self.bend1.cab, self.bend2.cab, self.cabq ]

    @PS.CommandExc
    def Lock(self):
        self.bend1.lock()
        self.bend2.lock()
        self.cab1.lock()
        self.cab2.lock()

    @PS.CommandExc
    def Unlock(self):
        self.bend1.unlock()
        self.bend2.unlock()
        self.cab1.unlock()
        self.cab2.unlock()

    def shiver(self, aname, x,y):
        self.__shiver.setdefault(aname,0)
        self.__shiver[aname] += 1
        return (x if self.__shiver[aname] % 2 else y)

    def shiver_name(self, aname):
        return (self.bend1,'bend1') if self.__shiver[aname] % 2 else (self.bend2, 'bend2')

    def distill_ne_quality(self, quality, x,y):
        if quality==AQ_INVALID: return AQ_INVALID
        r = x.value != y.value
        try:
            r = bool(r)
        except ValueError:
            r = any(r)
        return AQ_ALARM if r else quality

    def distill_waveform_quality(self, quality, x,y):
            return AQ_ALARM if tuple(x.value) != tuple(y.value) else quality


    def read_attr1(self, bend, attr):
        '''helper function to read value from 1 bending PS
        '''
        aname = attr.get_name()
        try:
            return bend.read_attribute(aname)
        except Tg.DevFailed, fail:
            reason = fail[0].reason
            if reason == 'API_AttrNotAllowed':
                return
            elif reason == 'PyDs_PythonError':
                return
#                raise PS.PS_Exception(fail[0].desc)
            else:
                raise

    @PS.AttrExc
    def read_attribute(self, attr, qual_fun=None):
        try:
            if time()<self.next_update_t:
                attr.set_quality(AQ_INVALID)
                return
            aname = attr.get_name()
            aval1 = self.read_attr1(self.bend1, attr)
            aval2 = self.read_attr1(self.bend2, attr)
            if aval1 is None or aval2 is None:
                attr.set_quality(AQ_INVALID)
                return

            quality = PS.combine_aq(aval1.quality, aval2.quality)
            timestamp = min(tv2time(aval1.time),tv2time(aval2.time))

            if qual_fun is None:
                quality = self.distill_ne_quality(quality, aval1, aval2)
            else:
                quality = qual_fun(quality, aval1, aval2)

            x = self.shiver(aname, aval1.value, aval2.value)
            if not aval1.w_value is None and not aval2.w_value is None:
                w = self.shiver(aname+'_W', aval1.w_value, aval2.w_value)
                attr.set_write_value(w)

            if quality==AQ_INVALID:
                setattr(self, '_a'+aname, None)
                attr.set_quality(AQ_INVALID)
            else:
                setattr(self, '_a'+aname, x)
                attr.set_value_date_quality(x, timestamp, quality)
        except Tg.DevFailed:
            self.delay_update()    
            raise

    def distill_I_quality(self, quality, aval1, aval2):
        diff = abs(aval1.value - aval2.value)
        if self._aWaveGeneration:
            quality =  AQ_CHANGING
        elif quality == AQ_VALID:
            if diff > self.AbsDiff:
                quality = AQ_WARNING
            if diff > 2*self.AbsDiff:
                quality = AQ_ALARM
        return quality

    def is_Voltage_allowed(self, write):
        return not self._aWaveGeneration

    @PS.AttrExc
    def read_Current1(self, attr):
        self._read_CurrentX(self.bend1, attr)

    @PS.ExceptionHandler
    def read_Current2(self, attr):
        self._read_CurrentX(self.bend2, attr)

    def _read_CurrentX(self, bend_x, attr):
        aval = bend_x.read_attribute('Current')
        I = aval.value
        timestamp = tv2time(aval.time)
        quality = aval.quality
        attr.set_value_date_quality(I, timestamp, quality)

    PS.CommandExc
    def On(self):
        self.set_state(DevState.INIT)
        self.set_status('switching on...')
        self.switching = SWITCH_ON
        self.switch_eta = time() + self.estimate_switch_on_time()
        self.upswitch_on(self.bend1)
        self.upswitch_on(self.bend2)

    PS.CommandExc
    def Off(self):
        self.set_state(DevState.INIT)
        self.set_status('switching off...')
        self.switching = SWITCH_OFF
        self.switch_eta = time() + self.estimate_switch_off_time()
        self.upswitch_off(self.bend1)
        self.upswitch_off(self.bend2)

    def est1_on_t(self, b, c):
        '''initial estimate how long it takes from the current state to
           bending power supply on, depending on cabinet state c and
           power supply state b.
        '''
        if c in CAB_ON_T:
            t = CAB_ON_T[c]
            if b in BEND_ON_T:
                return t+BEND_ON_T[b]
        return 0.0

    def est1_off_t(self, b, c):
        '''initial estimate how long it takes from the current state to switch
           bending power supply off, depending on cabinet state c and
           power supply state b.
        '''
        return BEND_OFF_T.get(b,0.0)

    def estimate_switch_on_time(self, mc1=None, mc2=None):
        if mc1 is None: mc1 = self.mac_state(self.bend1)
        if mc2 is None: mc2 = self.mac_state(self.bend2)
        on1_t = self.est1_on_t(*mc1)
        on2_t = self.est1_on_t(*mc2)
        return max(on1_t, on2_t)

    def estimate_switch_off_time(self, mc1=None, mc2=None):
        if mc1 is None: mc1 = self.mac_state(self.bend1)
        if mc2 is None: mc2 = self.mac_state(self.bend2)
        off1_t = self.est1_off_t(*mc1)
        off2_t = self.est1_off_t(*mc2)
        return max(off1_t, off2_t)

    @PS.CommandExc
    def UpdateState(self):
        if time()<self.next_update_t: return
        try:
            if self.switching == SWITCH_ON:
                fin = self.upswitch_on(self.bend1) and self.upswitch_on(self.bend2)
                self.update_switch_status('on', fin)
            elif self.switching == SWITCH_OFF:
                fin = self.upswitch_off(self.bend1) and self.upswitch_off(self.bend2)
                self.update_switch_status('off', fin)

        except Exception:
            self.switching = SWITCH_NEUTRAL
            raise

        finally:
            if not self.switching in (SWITCH_ON, SWITCH_OFF):
                self.update_neutral()


    def update_switch_status(self, switch, fin):
        if fin:
            self.switching = SWITCH_NEUTRAL
            self.update_neutral()
        else:
            rem_t = self.switch_eta - time()
            if rem_t > 0:
                self.set_status('switching %s, %.0fs remaining' % (switch, rem_t))
            else:
                self.set_status('switching %s' % switch)


    def update_neutral(self):
        state = DevState.FAULT
        try:
            # defines two shortcuts to improve readability later
            bend1, bend2 = self.bend1, self.bend2

            # first new state is determined
            b1_state, b2_state = bend1.State(), bend2.State()

            # if States are equal it is used as-is
            if b1_state == b2_state:
                state = b1_state

            elif b1_state == DevState.FAULT or b2_state == DevState.FAULT:
                state = DevState.FAULT

            elif b1_state == DevState.ALARM or b2_state == DevState.ALARM:
                state = DevState.ALARM

            elif b1_state == DevState.MOVING or b2_state==DevState.MOVING:
                state = DevState.MOVING

            else:
                state = DevState.ALARM

            bss1 = bend1.read_attribute('ShortStatus').value
            bss2 = bend2.read_attribute('ShortStatus').value

              # if ShortStatus are equal the same
      #        if bss1=='cabinet ready':
      #            short_status = 'power supply off'

            if bss1==bss2:
                short_status = bss1

            else:
                short_status = bss1 + "/" + bss2
                print short_status, len(short_status)
                if len(short_status)>60:
                    a = str(b1_state)
                    b = str(b2_state)
                    if a==b:    
                        short_status = a
                    else:
                        short_status = a+' / '+b

            b1_status = bend1.Status()
            b2_status = bend2.Status()

            # if Status is the same, use as-is
    #        if b1_status=='cabinet ready':
    #            status = 'power supply off'

            if b1_status==b2_status:
                status = b1_status

            elif bss1!=bss2:
                status = short_status

            else:
                status = b1_status + ' \n ' + b2_status

        except Tg.CommunicationFailed, commfail:
                status = 'communication failed'
                short_status = 'communication failed'
                self.delay_update_state()

        except Tg.DevFailed, d:
                status = 'error: %s' % d[-1].desc
                short_status = 'error: %s' % (d[-1].desc,)
                self.delay_update()

        except Exception, e:
            status = str(e)
            short_status = str(e)
            self.delay_updatee()

        finally:
            self.STAT.set_stat2(state, short_status, status)

    def delay_update(self, t=10):
          self.next_update_t = time()+t

    def upswitch_on(self, bend):
        '''Switches one bending power supply on.
           Returns True once PS are on otherwise None or False.
        '''
        c,b = self.mac_state(bend)

        if c == CAB_OFF_STATE:
            bend.cab.On()

        elif c in CAB_ON_STATES and b == BEND_OFF_STATE:
            bend.On()

        elif c in CAB_ON_STATES and b == BEND_ON_STATE:
            return True

        else:
            return True

    def upswitch_off(self, bend):
        '''Switches one bending power supply off.
           Returns True once PS are on otherwise None or False.

        '''
        c,b = self.mac_state(bend)

        if b == BEND_OFF_STATE:
            return True

        elif b == BEND_ON_STATE:
            bend.Off()

        else:
            return True


    def mac_state(self, bend):
        baval = bend.read_attribute('MachineState')
        cabaval = bend.cab.read_attribute('MachineState')
        assert baval.quality == AQ_VALID
# TODO: possibly the value could be non if qualiy INVALID
#        assert cabaval.quality == AQ_VALID
        c,b = cabaval.value, baval.value
        return c,b

    ### Attributes ###
    @PS.AttrExc
    def write_attribute(self, attr):
        try:
          if time()<self.next_update_t:
              raise PS.PS_Exception('devices proxies are not available')
          aname = attr.get_name()
          data = attr.get_write_value()
          self.bend1.write_attribute_asynch(aname, data, PU.nop)
          self.bend2.write_attribute_asynch(aname, data, PU.nop)
        except Tg.DevFailed:
          self.delay_update()

    def read_WaveLength(self, attr):
        self.read_attribute(attr)

    def read_Waveform(self, attr):
        self.read_attribute(attr, self.distill_waveform_quality)

    def write_WaveGeneration(self, attr):
        self.write_attribute(attr)

    def write_Waveform(self, attr):
        self.write_attribute(attr)

    def read_WaveX(self, attr):
        self.read_attribute(attr)

    def write_WaveX(self,attr):
        self.write_attribute(attr)

    def read_TriggerMask(self, attr):
        self.read_attribute(attr)

    def read_Voltage(self, attr):
        self.read_attribute(attr)

    def read_Current(self, attr):
        self.read_attribute(attr, self.distill_I_quality)

    def write_CurrentSetpoint(self, attr):
        self.write_attribute(attr)

    def read_CurrentSetpoint(self, attr):
        self.read_attribute(attr)

    @PS.CommandExc
    def Sync(self):

        # checks state of power supplies
        for d in self.sync_devices:
            aval = d.read_attribute('MachineState')
            if aval.quality != AQ_VALID:
                raise PS.PS_Exception('MachineState attribute is not valid')
            if aval.value != STATE_SYNC:
                raise PS.PS_Exception('device %r not ready to be sync\'d' % self.get_name())

        # checks and switches off triggers
        evr_state = self.trig.State()
        if not evr_state in (DevState.ON, DevState.OFF):
            raise PS.PS_Exception('event receiver is in %s state, must be ON or OFF')

        try:
            self.trig.Off()

            # sends SYNC commands
            for d in self.sync_devices:
                d.Command( ['SYNC'] )


        finally:
            # re-enables trigger if they were enabled before
            if evr_state == DevState.ON:
                self.trig.On()

    @PS.CommandExc
    def ResetInterlocks(self):
        PS.PowerSupply.ResetInterlocks(self)
        self.all('ResetInterlocks')

    @PS.AttrExc
    def read_Errors(self, attr):
        ls = []
        BE1 = self.bend1.read_attribute('Errors').value
        BE2 = self.bend2.read_attribute('Errors').value
        if BE1 is None:
            BE1 = []

        if BE2 is None:
            BE2 = []

        for e1 in BE1:
            if e1 not in BE2:
                ls.append('bend1: '+e1)
            else:
                ls.append(e1)

        for e2 in BE2:
            if e2 not in BE1:
                ls.append('bend2: '+e2)

        self.errors = ls
        attr.set_value(self.errors)


    def read_RemoteMode(self, attr):
        self.read_attribute(attr)

    @PS.CommandExc
    def ResetInterlocks(self):
        PS.PowerSupply.ResetInterlocks(self)
        fail = 0
        exc = None
        try:
            self.bend1.ResetInterlocks()
        except Exception,exc1:
            self._exception('resetting bending 1 failed')
            exc = exc1

        try:
            self.bend2.ResetInterlocks()
        except Exception,exc1:
            self._exception('resetting bending 2 failed')
            exc = exc2

        if exc: raise exc

    @PS.AttrExc
    def read_WaveStatus(self, attr):
        try:
            av1 = self.bend1['WaveStatus']
            av2 = self.bend2['WaveStatus']

        except Tg.DevFailed, df:
            err = df[-1]
            attr.set_value_date_quality(err.desc, time(), AQ_ALARM)
            return

        except Exception, exc:
            attr.set_value_date_quality(str(exc).desc, time(), AQ_ALARM)
            return


        value = 'not updated'
        timestamp = min(tv2time(av1.time),tv2time(av2.time))
        quality = PS.combine_aq(av1.quality, av2.quality)

        v1, seconds1 = strip_s(av1.value)
        v2, seconds2 = strip_s(av2.value)
        seconds = max(seconds1, seconds2)

        if v1==v2:
            value = v1
            if seconds:
                value += ' %.2fs' % seconds
        else:
            value = v1 + ' / ' + v2
        attr.set_value_date_quality(value, timestamp, quality)

    def read_WaveDuration(self, attr):
        self.read_attribute(attr)

    def read_RegulationFrequency(self,attr):
        self.read_attribute(attr)

    def read_WaveInterpolation(self, attr):
        self.read_attribute(attr)

    def read_WaveGeneration(self, attr):
        self.read_attribute(attr)

    def read_WaveOffset(self, attr):
        self.read_attribute(attr)

    def write_WaveOffset(self, attr):
        self.write_attribute(attr)

    def read_WaveName(self, attr):
        self.read_attribute(attr)

    def write_WaveName(self, wattr):
        self.write_attribute(wattr)

    def read_WaveId(self, attr):
        self.read_attribute(attr)

class BrukerBend_PS_Class(Tg.DeviceClass):

        FMT = '%6.4f'
        #       Class Properties
        class_property_list = {
                }


        #       Device Properties
        device_property_list = PS.gen_property_list()
        device_property_list.update({
            'Trigger' :
                [ Tg.DevString,
                    "Event receiver sending trigger for bending and quadrupoles", 'bo04/ti/evr-cpc1502-a'],

            'Bend1':
                [Tg.DevString,
                "Name of device controlling bending 1.",
            'bo/pc/bend-1' ],
            'Bend2':
                [Tg.DevString,
                "Name of device controlling bending 2.",
                'bo/pc/bend-2' ],
                'QuadCabinet':
            [Tg.DevString,
            "Name of the quadrupole cabinet, used for Sync command.",
            'bo/ct/pc-q' ],
                })


        #       Command definitions
        cmd_list = PS.gen_cmd_list(opt=('UpdateState',))
        cmd_list['UpdateState'][2]['polling period'] = 20000
        cmd_list.update({
          'On' : [ [Tg.DevVoid],[Tg.DevVoid]],
          'Off' : [ [Tg.DevVoid],[Tg.DevVoid]],
          'Sync' : [ [Tg.DevVoid, 'sync sync'],[Tg.DevVoid],
              { 'display level' : Tg.DispLevel.EXPERT }
          ],
       })



        #       Attribute definitions
        attr_list = PS.gen_attr_list(max_err=100,opt=('Current','CurrentSetpoint','Voltage'))
        attr_list.update({
                'Current1': attr_list['Current'],
                'Current2': attr_list['Current'],
                'Voltage': attr_list['Voltage'],
                'WaveGeneration' : [[ Tg.DevBoolean, Tg.SCALAR, Tg.READ_WRITE ]],
                'Waveform' : [[ Tg.DevDouble, Tg.SPECTRUM, Tg.READ_WRITE, 2**14] , {} ],
                'WaveX' : [[ Tg.DevDouble, Tg.SPECTRUM, Tg.READ_WRITE, 2**14] , {} ],
                'WaveLength' : [[ Tg.DevShort, Tg.SCALAR, Tg.READ], {'unit' : 'points'} ],
                'WaveStatus' : [[ Tg.DevString, Tg.SCALAR, Tg.READ ]],
                'WaveName' : [[ Tg.DevString, Tg.SCALAR, Tg.READ_WRITE ]],
                'WaveId' : [[ Tg.DevLong, Tg.SCALAR, Tg.READ ]],
                'WaveDuration' : [[ Tg.DevDouble, Tg.SCALAR, Tg.READ ], {'unit': 'ms'} ],
                'WaveOffset' : [[ Tg.DevDouble, Tg.SCALAR, Tg.READ_WRITE ], {'unit': 'A'} ],
                'WaveInterpolation' : [[ Tg.DevShort, Tg.SCALAR, Tg.READ_WRITE ], { 'unit': 'log2(periods/point)' } ],
                'RegulationFrequency' : [[ Tg.DevDouble, Tg.SCALAR, Tg.READ ], { 'unit' : 'kHz'} ],
                'TriggerMask': [[Tg.DevLong, Tg.SCALAR,  Tg.READ_WRITE],
                    { 'min value' : 0, 'max value' : 0x3fffffff,
    'description' : '''number of triggers to consider:
0:no wave generated, 1:generate single wave, 0x3fffffff:continously''' }
                    ]}
        )
        attr_list['CurrentSetpoint'][1]['format'] = FMT
        attr_list['Voltage'][1]['format'] = FMT
        attr_list['Current'][1]['format'] = FMT

        #  BrukerBend_PSClass Constructor
        def __init__(self, name):
                Tg.DeviceClass.__init__(self, name)
                self.set_type(name);


if __name__ == '__main__':
    classes = (BrukerBend_PS, )
    PS.tango_main( 'BrukerBend_PS', sys.argv, classes)
